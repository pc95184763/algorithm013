学习笔记 

1.twoSum 
   a.这道题刚开始做的时候，第一个想法就是使用暴力遍历，对数组中每一个元素去查找能够相加达到target 的元素，这个解法的复杂度为O(n * n)。
   b.后来想到用字典来存储数组元素，然后去字典中寻找组成target 的另一个值，此时的时间复杂度为O(N * log N )
   c.看到最优化的解法是一遍将数组中的元素放入字典中，一边在字典中查找，这样在最坏情况下的时间复杂度为O (N * log N)

2.plusOne
   这道题的解题流程参考了最佳答案，将一个数加一分为两种情况, 第一种情况是最高位不会进1，比如 6899 + 1 = 6900 即进位不会导致原数字长度的变化，而判断是否进位只需要看加1的那一位在加一后模10是否为0

   第二种情况，最高位有进位 ： 比如  9999 + 1 = 10000 此时需要 重新申请大一位的数组，只需要将最高位设置为1即可。
   
3.mergeTwoLists
   链表中的题目，在两链表中设置一个头，然后分情况，若是两个链式结构都不为Null，将头链接小的一端，直到有一条为空，此时将剩下的一条全部链接即可。